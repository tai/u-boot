#include <common.h>
#include <command.h>
#include <malloc.h>
#include <usb.h>
#include "compiler.h"
#include "usb_upgrade.h"
#include "usb_upgrade_err_code.h"
#include <version_autogenerated.h>

typedef struct{
	unsigned int  manufactor_code;
	unsigned int  hardware_version;
}stb_ids_st;

typedef struct{
	unsigned char load_sequence_number;
	unsigned int  package_tool_version;
	unsigned int  create_date;
	unsigned int  create_time;
}stb_upgrade_log_info_st;

typedef union
{
	unsigned int u32;
	char arr[4];
}u32_union;

typedef union
{
	unsigned long long u64;
	char arr[8];
}u64_union;

static download_header dlh;
static partition_header *ph=NULL;
static evn_update_st env_up;
static digital_signature_st digital_signature;
static int au_usb_stor_curr_dev; /* current device */
static char *global_p=NULL;
static char filename[256];
static char **p_parttions=NULL;

static unsigned int get_uint_data(char **p)
{
	u32_union x;
	memcpy(x.arr,*p,sizeof(x.arr));
	*p+=sizeof(x.arr);
	
	x.u32=be32_to_cpu(x.u32);

	return x.u32;
}

int fill_uint_data(char **p,unsigned int v,unsigned int *crc)
{
	u32_union x;
	x.u32=cpu_to_be32(v);
	if(NULL != crc)
	{
		*crc=crc32(*crc,x.arr,sizeof(x.arr));
	}
	memcpy(*p,x.arr,sizeof(x.arr));
	*p+=sizeof(x.arr);
	return sizeof(x.arr);
}

static unsigned long long get_llint_data(char **p)
{
	u64_union x;

	memcpy(x.arr,*p,sizeof(x.arr));
	*p+=sizeof(x.arr);
	
	x.u64=be64_to_cpu(x.u64);

	return x.u64;

}

static void get_string_data(char **psrc,char *pdst,unsigned int len)
{
	memcpy(pdst,*psrc,len);
	*psrc+=len;
}

static int verify_table_header(char *p)
{
	u32_union x;
	unsigned int section_length;
	unsigned int crc;

	memcpy(x.arr,p,sizeof(x.arr));
	x.u32=be32_to_cpu(x.u32);
	section_length=x.u32;
	if(0x100000<section_length)
	{
		return ERR_NO_TABLE_HEADER_TOO_LONG;
	}
	crc=crc32(0,p,section_length);
	memcpy(x.arr,p+section_length,sizeof(x.arr));
	x.u32=be32_to_cpu(x.u32);

	if(x.u32 != crc)
		return ERR_TABLE_HEADER_CRC;

	return ERR_NO_ERROR;
}

static int write_nvram_eeprom(char *addr,unsigned long long offset,unsigned long long size)
{
	int rc;

	char argv0[20];
	char argv1[20];
	char argv2[20];
	char argv3[20];
	char argv4[20];
	unsigned long long len;
	
	printf("running:eeprom write %p %llX %llX\n",addr, offset, size);
	
	do
	{
		len=size>0x20?0x20:size;

		//udelay(10000000);

		sprintf( argv0, "%s", "eeprom" );
		sprintf( argv1, "%s", "write" );
		sprintf( argv2, "%p", addr );
		sprintf( argv3, "%llX", offset );
		sprintf( argv4, "%llX", len );
		char *argv[] = {
			argv0,
			argv1,
			argv2,
			argv3,
			argv4
		};
		
		rc = do_eeprom( NULL, 0, sizeof(argv)/sizeof(char *), argv );

		if (rc != 0) {
			printf("Flashing failed due to error %d\n", rc);
			return ERR_NVRAM_EEPROM_WRITE;
		}
		
		size-=len;
		addr+=len;
		offset+=len;
	}while(size>0);
	
	return ERR_NO_ERROR;
}

static int erase_nvram_spi_flash(unsigned long long offset,unsigned long long size)
{
	int rc;

	char argv0[20];
	char argv1[20];
	char argv2[20];
	
	sprintf( argv0, "%s", "sfer" );
	sprintf( argv1, "%llX", offset );
	sprintf( argv2, "+%llX", size );
	
	char *argv[] = {
		argv0,
		argv1,
		argv2
	};
	printf("running:%s %s %s\n", argv0, argv1, argv2);
	rc = do_sflasher( NULL, 0, sizeof(argv)/sizeof(char *), argv );
	
	if (rc != 0) {
		printf("Flashing failed due to error %d\n", rc);
		return ERR_NVRAM_SPI_FLASH_ERASE;
	}
	return ERR_NO_ERROR;
}

static int write_nvram_spi_flash(char *addr,unsigned long long offset,unsigned long long size)
{
	int rc;

	char argv0[20];
	char argv1[20];
	char argv2[20];
	char argv3[20];
	
	sprintf( argv0, "%s", "sfwr" );
	sprintf( argv1, "%p", addr );
	sprintf( argv2, "%llX", offset );
	sprintf( argv3, "%llX", size );
	char *argv[] = {
		argv0,
		argv1,
		argv2,
		argv3
	};
	printf("running:%s %s %s %s\n", argv0, argv1, argv2, argv3);
	rc = do_sflashwr( NULL, 0, sizeof(argv)/sizeof(char *), argv );

	if (rc != 0) {
		printf("Flashing failed due to error %d\n", rc);
		return ERR_NVRAM_SPI_FLASH_WRITE;
	}
	return ERR_NO_ERROR;
}

static int erase_nvram_nand_flash(unsigned long long offset,unsigned long long size)
{
	int rc;

	char argv0[20];
	char argv1[20];
	char argv2[20];
	char argv3[20];
	
	sprintf( argv0, "%s", "nand" );
	sprintf( argv1, "%s", "erase.spread" );
	sprintf( argv2, "%llX", offset );
	sprintf( argv3, "%llX", size );
	
	char *argv[] = {
		argv0,
		argv1,
		argv2,
		argv3
	};
	
	printf("running:%s %s %s %s\n", argv0, argv1, argv2, argv3);
	rc = do_nand( NULL, 0, sizeof(argv)/sizeof(char *), argv );
	
	if (rc != 0) {
		printf("Flashing failed due to error %d\n", rc);
		return ERR_NVRAM_NAND_FLASH_ERASE;
	}
	return ERR_NO_ERROR;
}

static int write_nvram_nand_flash(filesystem_type_e type,char *addr,unsigned long long offset,unsigned long long size)
{
	int rc;

	char argv0[20];
	char argv1[20];
	char argv2[20];
	char argv3[20];
	char argv4[20];
	
	sprintf( argv0, "%s", "nand" );
	if(JFFS2_FILE_SYSTEM_TYPE == type)
		sprintf( argv1, "%s", "write.jffs2" );
	else if(YAFFS_FILE_SYSTEM_TYPE == type)
		sprintf( argv1, "%s", "write.yaffs" );
	else
		return 1;
	sprintf( argv2, "%p", addr );
	sprintf( argv3, "%llX", offset );
	sprintf( argv4, "%llX", size );
	char *argv[] = {
		argv0,
		argv1,
		argv2,
		argv3,
		argv4
	};
	printf("running:%s %s %s %s %s\n", argv0, argv1, argv2, argv3, argv4);
	rc = do_nand( NULL, 0, sizeof(argv)/sizeof(char *), argv );

	if (rc != 0) {
		printf("Flashing failed due to error %d\n", rc);
		return ERR_NVRAM_NAND_FLASH_WRITE;
	}
	return ERR_NO_ERROR;
}

static int get_stb_ids(stb_ids_st *id)
{
	char *p_manufactor_code=getenv("manufactor_code");
	char *p_hardware_version=getenv("hardware_version");

	if(NULL == p_manufactor_code || NULL == p_hardware_version)
		return 1;
	
	id->manufactor_code=simple_strtoul(p_manufactor_code, NULL, 16);
	id->hardware_version=simple_strtoul(p_hardware_version, NULL, 16);

	return 0;
}

static int set_stb_ids(stb_ids_st *id)
{
	char buf[20];
	
	sprintf(buf,"0x%X",id->manufactor_code);
	setenv("manufactor_code", buf);
	sprintf(buf,"0x%X",id->hardware_version);
	setenv("hardware_version", buf);
	
	return 0;
}

static int get_stb_upgrade_log_info(stb_upgrade_log_info_st *log)
{
	char *p_load_sequence_number=getenv("load_sequence_number");
	char *p_package_tool_version=getenv("package_tool_version");
	char *p_create_date=getenv("create_date");
	char *p_create_time=getenv("create_time");

	if(NULL == p_load_sequence_number || NULL == p_package_tool_version || 
		NULL == p_create_date || NULL == p_create_time)
	{
		return 1;
	}

	log->load_sequence_number=simple_strtoul(p_load_sequence_number, NULL, 16);
	log->package_tool_version=simple_strtoul(p_package_tool_version, NULL, 10);
	log->create_date=simple_strtoul(p_create_date, NULL, 16);
	log->create_time=simple_strtoul(p_create_time, NULL, 16);

	return 0;
}

static int set_stb_upgrade_log_info(stb_upgrade_log_info_st *log)
{
	char buf[20];
	
	sprintf(buf,"0x%X",log->load_sequence_number);
	setenv("load_sequence_number", buf);
	sprintf(buf,"%d",log->package_tool_version);
	setenv("package_tool_version", buf);
	sprintf(buf,"0x%X",log->create_date);
	setenv("create_date", buf);
	sprintf(buf,"0x%X",log->create_time);
	setenv("create_time", buf);
	
	return 0;
}

static unsigned int get_uboot_version_num(void)
{
	char *s=strstr(PLAIN_VERSION,"svn");
	return simple_strtoul(s+3, NULL, 10);
}

static int parse_dlh_info(void)
{
	int i;
	unsigned int err=0;
	static stb_ids_st stb_ids;
	unsigned int num;
	
	if(ERR_NO_ERROR != (err = verify_table_header(global_p)))
	{
		return err;
	}

	dlh.section_length=get_uint_data(&global_p);
	dlh.digital_signature=(get_uint_data(&global_p)>>31);
	printf("digital_signature=[%d].\n",dlh.digital_signature);
	dlh.manufactor_code=get_uint_data(&global_p);
	printf("manufactor_code=[0x%X].\n",dlh.manufactor_code);
	dlh.hardware_version=get_uint_data(&global_p);
	printf("hardware_version=[0x%X].\n",dlh.hardware_version);	
	dlh.package_tool_version=get_uint_data(&global_p);
	printf("package_tool_version=[%d].\n",dlh.package_tool_version);
	dlh.minimum_uboot_version=get_uint_data(&global_p);
	printf("minimum_uboot_version=[%d].\n",dlh.minimum_uboot_version);
	dlh.create_date=get_uint_data(&global_p);
	printf("create_date:%02d%02d-%02d-%02d.\n",
		dlh.create_date>>24,(dlh.create_date&0x00FF0000)>>16,(dlh.create_date&0x0000FF00)>>8,(dlh.create_date&0xFF));
	num=get_uint_data(&global_p);
	dlh.create_time=(num>>8);
	printf("create_time:%02d:%02d:%02d.\n",(num&0x00FF0000)>>16,(num&0x0000FF00)>>8,(num&0xFF));
	dlh.load_sequence_number=num&0xFF;
	printf("load_sequence_number=[%d].\n",dlh.load_sequence_number);
	dlh.partition_count=get_uint_data(&global_p);
	printf("partition_count=[%d].\n",dlh.partition_count);

	if(0x1000<dlh.partition_count)//avoid invalid data.
	{
		return ERR_DLH_TOO_MANY_PARTITIONS;
	}

	dlh.files=(partition_file *)calloc(dlh.partition_count , sizeof(partition_file));
	for(i=0;i<dlh.partition_count;i++)
	{
		dlh.files[i].name_len=get_uint_data(&global_p);
		
		if(256<dlh.files[i].name_len)//avoid invalid data.
		{
			return ERR_DLH_TOO_LONG_FILE_NAME;
		}
		
		dlh.files[i].name=(char *)calloc(1,dlh.files[i].name_len+1);
		get_string_data(&global_p,dlh.files[i].name,dlh.files[i].name_len);
	}

	get_uint_data(&global_p);//discard crc32
	
	for(i=0;i<dlh.partition_count;i++)
	{
		printf("partition_%d_filename=[%s].\n",i,dlh.files[i].name);
	}
	
	if(0==get_stb_ids(&stb_ids))
	{
		if(dlh.manufactor_code != stb_ids.manufactor_code)
		{
			return ERR_DLH_INVALID_MANUFACTURE_CODE;
		}
		if(dlh.hardware_version != stb_ids.hardware_version)
		{
			return ERR_DLH_INVALID_HARDWARE_CODE;
		}
	}

	if(dlh.minimum_uboot_version>get_uboot_version_num())
	{
		return ERR_DLH_TOO_LOW_UBOOT_VERSION;
	}
	
	return ERR_NO_ERROR;
}

static int parse_ph_conf(unsigned int ph_index)
{
	u32_union x_32;	
	unsigned int err=0;

	if(ERR_NO_ERROR != (err = verify_table_header(global_p)))
	{
		return err;
	}
	
	ph[ph_index].section_length=get_uint_data(&global_p);
	get_string_data(&global_p,x_32.arr,sizeof(x_32.arr));
	ph[ph_index].memory_type=x_32.arr[0]>>4;
	printf("ph[%d].memory_type=[%d].\n",ph_index,ph[ph_index].memory_type);
	ph[ph_index].file_system_type=x_32.arr[0]&0x0F;
	printf("ph[%d].file_system_type=[%d].\n",ph_index,ph[ph_index].file_system_type);
	ph[ph_index].erase_only=x_32.arr[1]>>7;
	printf("ph[%d].erase_only=[%d].\n",ph_index,ph[ph_index].erase_only);

	ph[ph_index].start_address=get_llint_data(&global_p);
	printf("ph[%d].start_address=[0x%llX].\n",ph_index,ph[ph_index].start_address);
	ph[ph_index].original_size=get_llint_data(&global_p);
	printf("ph[%d].original_size=[0x%llX].\n",ph_index,ph[ph_index].original_size);
	ph[ph_index].partition_size=get_llint_data(&global_p);
	printf("ph[%d].partition_size=[0x%llX].\n",ph_index,ph[ph_index].partition_size);
	ph[ph_index].o_crc_32=get_uint_data(&global_p);
	printf("ph[%d].o_crc_32=[0x%X].\n",ph_index,ph[ph_index].o_crc_32);

	get_uint_data(&global_p);//discard crc32
	
	return ERR_NO_ERROR;	
}

static int get_partition_files(void)
{
	int i;
	unsigned int err=0;
	
	if(NULL == ph)
	{
		ph=(partition_header *)calloc(dlh.partition_count,sizeof(partition_header));
	}

	if(NULL == p_parttions)
	{
		p_parttions=(char **)calloc(dlh.partition_count,sizeof(unsigned char *));
	}

	for(i=0;i<dlh.partition_count;i++)
	{
		unsigned int o_crc_32;

		if(ERR_NO_ERROR != (err = parse_ph_conf(i)))
		{
			return err;
		}
		p_parttions[i]=global_p;
		global_p+=ph[i].original_size;

		o_crc_32=crc32(0,(unsigned char *)p_parttions[i],ph[i].original_size);
		if(o_crc_32 != ph[i].o_crc_32)
		{
			printf("original CRC error!\n");
			return ERR_PARTITION_DATA_CRC;
		}
	}

	return ERR_NO_ERROR;
}

static int get_env(void)
{	
	int i;
	unsigned int err=0;

	if(ERR_NO_ERROR != (err = verify_table_header(global_p)))
	{
		return err;
	}
	
	env_up.section_length=get_uint_data(&global_p);
	env_up.env_count=get_uint_data(&global_p);
	printf("env_count=[0x%X].\n",env_up.env_count);
	get_uint_data(&global_p);//reserved.
	env_up.nodes=(env_update_node *)calloc(env_up.env_count, sizeof(env_update_node));
	for(i=0;i<env_up.env_count;i++)
	{
		env_up.nodes[i].name_len=get_uint_data(&global_p);
		env_up.nodes[i].name=(char *)calloc(1,env_up.nodes[i].name_len+1);
		get_string_data(&global_p,env_up.nodes[i].name,env_up.nodes[i].name_len);
		printf("env_up.nodes[%d].name=[%s].\n",i,env_up.nodes[i].name);
		
		env_up.nodes[i].value_len=get_uint_data(&global_p);
		env_up.nodes[i].value=(char *)calloc(1,env_up.nodes[i].value_len+1);
		get_string_data(&global_p,env_up.nodes[i].value,env_up.nodes[i].value_len);
		printf("env_up.nodes[%d].value=[%s].\n",i,env_up.nodes[i].value);		
	}

	get_uint_data(&global_p);//discard crc32
	
	return ERR_NO_ERROR;
	
}

static int get_signature_info(void)
{	
	unsigned int x;
	unsigned int err=0;

	if(ERR_NO_ERROR != (err = verify_table_header(global_p)))
	{
		return err;
	}
	
	digital_signature.section_length=get_uint_data(&global_p);
	x=get_uint_data(&global_p);
	digital_signature.arithmetic=x>>26;
	digital_signature.signature_len=x&0x3FFFFFF;
	if(SIGNATURE_ARITHMETIC_RSA_SHA1 != digital_signature.arithmetic)
	{
		return ERR_UNSUPPORTED_SIGNATURE_ARITHMETIC;
	}

	digital_signature.signature_data=(char *)calloc(1,digital_signature.signature_len);
	get_string_data(&global_p,digital_signature.signature_data,digital_signature.signature_len);
	get_uint_data(&global_p);//discard crc32

	//we don't support digital signature in uboot for the time now due to the high cpu usage in uboot without dcache on.
	//on the other hand, if we make dcache on, the uboot maybe crash.
	
	return ERR_NO_ERROR;
	
}

static int write_partition_data(void)
{
	int i;
	unsigned int err=0;

	for(i=0;i<dlh.partition_count;i++)
	{
		if(EEPROM_MEMORY_TYPE == ph[i].memory_type)
		{	
			if(1 == ph[i].erase_only)
			{
				char *p=(char *)calloc(1,ph[i].partition_size);
				if(ERR_NO_ERROR != (err = write_nvram_eeprom(p,ph[i].start_address,ph[i].partition_size)))
				{
					return err;
				}
				free(p);
				p=NULL;
			}
			if(0 == ph[i].erase_only && 0 != ph[i].original_size)
			{
				if(ERR_NO_ERROR != (err = write_nvram_eeprom(p_parttions[i],ph[i].start_address,ph[i].original_size)))
				{
					return err;
				}
			}
		}
		else if(SPI_FLASH_MEMORY_TYPE == ph[i].memory_type)
		{
			if(1 == ph[i].erase_only || (0 == ph[i].erase_only && 0 != ph[i].original_size))
			{
				if(ERR_NO_ERROR != (err = erase_nvram_spi_flash(ph[i].start_address,ph[i].partition_size)))
				{
					return err;
				}
			}
			if(0 == ph[i].erase_only && 0 != ph[i].original_size)
			{
				if(ERR_NO_ERROR != (err = write_nvram_spi_flash(p_parttions[i],ph[i].start_address,ph[i].original_size)))
				{
					return err;
				}
			}
		}
		else if(NAND_FLASH_MEMORY_TYPE == ph[i].memory_type)
		{
			if(1 == ph[i].erase_only || (0 == ph[i].erase_only && 0 != ph[i].original_size))
			{
				if(ERR_NO_ERROR != (err = erase_nvram_nand_flash(ph[i].start_address,ph[i].partition_size)))
				{
					return err;
				}
			}
			if(0 == ph[i].erase_only && 0 != ph[i].original_size)
			{
				if(ERR_NO_ERROR != (err = write_nvram_nand_flash(ph[i].file_system_type,p_parttions[i],ph[i].start_address,ph[i].original_size)))
				{
					return err;
				}
			}
		}
	}

	return ERR_NO_ERROR;
}

static int write_env_data(void)
{
	unsigned int i=0;
	
	for(i=0;i<env_up.env_count;i++)
	{
		setenv(env_up.nodes[i].name, env_up.nodes[i].value);
	}

	if(0 != env_up.env_count)
		saveenv();

	return ERR_NO_ERROR;
}

static void display_err_on_fp(unsigned int err)
{
	const char char_numbers[16] =
		{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
 	char  err_chars[4];
	int i;
	
	if(ERR_NO_ERROR != err)
	{
		unsigned int j;

		printf("err=[0x%X].\n",err);
		
		for( i=0; i<4; i++ )
		{
			err_chars[i] = (char)err;
			err >>= 8;
		}
		i = 3;

		for(j=0;j<16;j++)
		{
			char  string[5]={0};
			sprintf(string, " %c%c%c", char_numbers[i],char_numbers[(err_chars[i]>>4)],char_numbers[err_chars[i]&0x0F]);

			fpc_init_show(string);
			udelay(1500000);
			
			if( i == 0 )
				i = 3;
			else
				i--;

			if (tstc()) {
				getc();
				break;
			}
		}
	}
	else
	{
		fpc_init_show("good");
	}
}

static int exit_upgrade(int  old_ctrlc,unsigned char upgrade_flag,unsigned int err)
{
	unsigned int i;
	
	display_err_on_fp(err);
	
	if(NULL != ph)
	{
		free(ph);
		ph=NULL;
	}
	
	if(NULL != dlh.files)
	{
		for(i=0;i<dlh.partition_count;i++)
		{
			free(dlh.files[i].name);
			dlh.files[i].name=NULL;
		}
		free(dlh.files);
		dlh.files=NULL;
	}

	if(NULL != env_up.nodes)
	{
		for(i=0;i<env_up.env_count;i++)
		{
			if(NULL != env_up.nodes[i].name)
			{
				free(env_up.nodes[i].name);
				env_up.nodes[i].name=NULL;
			}
		}
		free(env_up.nodes);
		env_up.nodes=NULL;
	}

	if(NULL != digital_signature.signature_data)
	{
		free(digital_signature.signature_data);
		digital_signature.signature_data=NULL;
	}
	
	if(NULL != p_parttions)
	{
		free(p_parttions);
		p_parttions=NULL;
	}
	
	if(1 == upgrade_flag)
	{
		usb_stop();
		/* restore the old state */
		disable_ctrlc(old_ctrlc);
	}

	return err;
}

static int do_upgrade(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	block_dev_desc_t *stor_dev=NULL;
	int  old_ctrlc;
	int sz;
	char *addr=NULL;
	unsigned char upgrade_flag=0;// 1:means USB upgrade, 2:menas IP upgrade.
	unsigned int err=0;
	stb_ids_st id;
	stb_upgrade_log_info_st upgrade_info;
	
	if (0 == strcmp(argv[1], "-i"))
	{		
		if(0 == get_stb_ids(&id))
		{
			printf("manufactor_code=0x%X.\n",id.manufactor_code);
			printf("hardware_version=0x%X.\n",id.hardware_version);
		}
		else			
			printf("Invalid STB IDs.\n");
		
		if(0 == get_stb_upgrade_log_info(&upgrade_info))
		{
			u32_union x;			
			printf("load_sequence_number=0x%X.\n",upgrade_info.load_sequence_number);
			printf("package_tool_version=%d.\n",upgrade_info.package_tool_version);
			x.u32=upgrade_info.create_date;
			x.u32=be32_to_cpu(x.u32);
			printf("create_date:%02d%02d-%02d-%02d.\n",x.arr[0],x.arr[1],x.arr[2],x.arr[3]);
			x.u32=upgrade_info.create_time;
			x.u32=be32_to_cpu(x.u32);
			printf("create_time:%02d:%02d:%02d.\n",x.arr[1],x.arr[2],x.arr[3]);		
		}
		else			
			printf("Invalid upgrade log info.\n");
		return 0;
	}
	else if (0 == strcmp(argv[1], "-a"))
	{
		if(0 != argv[2])
		{
			char *endptr;

			addr = (char *)simple_strtoul(argv[2], &endptr, 16);
			if(*endptr != '\0')
			{
				printf("'%s' is not a number\n", argv[2]);
				return 1;
			}
			upgrade_flag=2;
		}
		else
		{
			return cmd_usage(cmdtp);
		}
	}
	else if (0 == strcmp(argv[1], "-f"))
	{
		if(0 != argv[2])
		{
			strncpy(filename,argv[2],sizeof(filename)-1);
			filename[sizeof(filename)-1]=0;
			printf("filename=[%s].\n",filename);
			upgrade_flag=1;
		}
		else
		{
			return cmd_usage(cmdtp);
		}
	}
	else
	{
		return cmd_usage(cmdtp);
	}
	
	/* make sure that we see CTRL-C and save the old state */
	old_ctrlc = disable_ctrlc(1);

	if(1 == upgrade_flag)
	{
		au_usb_stor_curr_dev = -1;
		/* start USB */
		if (usb_stop() < 0) {
			debug ("usb_stop failed\n");
			return -1;
		}
		if (usb_init() < 0) {
			debug ("usb_init failed\n");
			return -1;
		}	

		/*
		 * check whether a storage device is attached (assume that it's
		 * a USB memory stick, since nothing else should be attached).
		 */
		au_usb_stor_curr_dev = usb_stor_scan(0);
		if (au_usb_stor_curr_dev == -1) {
			debug ("No device found. Not initialized?\n");
			return -1;
		}

		/* check whether it has a partition table */
		stor_dev = get_dev("usb", 0);
		if (stor_dev == NULL) {
			debug ("uknown device type\n");
			return -1;
		}
		if (fat_register_device(stor_dev, 1) != 0) {
			debug ("Unable to use USB %d:%d for fatls\n",
					au_usb_stor_curr_dev, 1);
			return -1;
		}
		if (file_fat_detectfs() != 0) {
			debug ("file_fat_detectfs failed\n");
		}

		/* make certain that HUSH is runnable */
		u_boot_hush_start();
		sz = file_fat_read(filename, CONFIG_USB_UPGRADE_DATA_ADDR, 0);
		if (sz <= 0) {
			debug ("file %s not found\n", filename);
			return -1;
		}
		global_p=(char *)CONFIG_USB_UPGRADE_DATA_ADDR;
	}
	else if(2 == upgrade_flag)
	{
		global_p=addr;
	}

	//start upgrade.
	printf("\n");
	if(ERR_NO_ERROR != (err = parse_dlh_info()))
	{
		return exit_upgrade(old_ctrlc,upgrade_flag,err);
	}

	if(ERR_NO_ERROR != (err = get_partition_files()))
	{
		return exit_upgrade(old_ctrlc,upgrade_flag,err);
	}

	if(ERR_NO_ERROR != (err = get_env()))
	{
		return exit_upgrade(old_ctrlc,upgrade_flag,err);
	}

	if(1 == dlh.digital_signature && ERR_NO_ERROR != (err = get_signature_info()))
	{
		return exit_upgrade(old_ctrlc,upgrade_flag,err);
	}

	if(ERR_NO_ERROR != (err = write_partition_data()))
	{
		return exit_upgrade(old_ctrlc,upgrade_flag,err);
	}

	if(ERR_NO_ERROR != (err = write_env_data()))
	{
		return exit_upgrade(old_ctrlc,upgrade_flag,err);
	}
	
	if(0 != get_stb_ids(&id))
	{
		id.manufactor_code=dlh.manufactor_code;
		id.hardware_version=dlh.hardware_version;
		set_stb_ids(&id);
	}

	upgrade_info.load_sequence_number=dlh.load_sequence_number;
	upgrade_info.package_tool_version=dlh.package_tool_version;
	upgrade_info.create_date=dlh.create_date;
	upgrade_info.create_time=dlh.create_time;
	set_stb_upgrade_log_info(&upgrade_info);

	return exit_upgrade(old_ctrlc,upgrade_flag,ERR_NO_ERROR);
}

U_BOOT_CMD(
	upgrade, 3, 0, do_upgrade,
	"USB/IP upgrade",
	"-i - show available IDs of this STB\n"
	"-a addr - read upgrade data from 'addr' address and upgrade this STB\n"
	"-f filename - read upgrade data from USB disk and upgrade this STB\n"
);
